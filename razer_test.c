#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <hidapi.h>

union transaction_id_union {
    unsigned char id;
    struct transaction_parts {
        unsigned char device : 3;
        unsigned char id : 5;
    } parts;
};

union command_id_union {
    unsigned char id;
    struct command_id_parts {
        unsigned char direction : 1;
        unsigned char id : 7;
    } parts;
};

typedef union razer_report {
    unsigned char  Data[256];
    struct {
        unsigned char status;
        union transaction_id_union transaction_id; /* */
        unsigned short remaining_packets; /* Big Endian */
        unsigned char protocol_type; /*0x0*/
        unsigned char data_size;
        unsigned char command_class;
        union command_id_union command_id;
        unsigned char arguments[80];
        unsigned char crc;/*xor'ed bytes of report*/
        unsigned char reserved; /*0x0*/
    } razer_report_inner;
} razer_report;

/**
 * Calculate the checksum for the usb message
 *
 * Checksum byte is stored in the 2nd last byte in the messages payload.
 * The checksum is generated by XORing all the bytes in the report starting
 * at byte number 2 (0 based) and ending at byte 88.
 */
unsigned char razer_calculate_crc(razer_report *report)
{
    /*second to last byte of report is a simple checksum*/
    /*just xor all bytes up with overflow and you are done*/
    unsigned char crc = 0;
    unsigned char *_report = (unsigned char *) report;

    unsigned int i;
    for (i = 2; i < 88; i++) {
        crc ^= _report[i];
    }

    return crc;
}

razer_report get_razer_report(unsigned char command_class, unsigned char command_id, unsigned char data_size)
{
    razer_report new_report;
    memset(&new_report, 0, sizeof(razer_report));

    new_report.razer_report_inner.status = 0x00;
    new_report.razer_report_inner.transaction_id.id = 0xFF;
    new_report.razer_report_inner.remaining_packets = 0x00;
    new_report.razer_report_inner.protocol_type = 0x00;
    new_report.razer_report_inner.command_class = command_class;
    new_report.razer_report_inner.command_id.id = command_id;
    new_report.razer_report_inner.data_size = data_size;

    return new_report;
}

razer_report razer_chroma_standard_set_led_brightness(unsigned char variable_storage, unsigned char led_id, unsigned char brightness)
{
    razer_report report = get_razer_report(0x03, 0x03, 0x03);
    report.razer_report_inner.arguments[0] = variable_storage;
    report.razer_report_inner.arguments[1] = led_id;
    report.razer_report_inner.arguments[2] = brightness;

    return report;
}


int main(int argc, char *argv[])
{
    int res;
    unsigned char buf[90];
#define MAX_STR 255
    wchar_t wstr[MAX_STR];
    hid_device *handle;
    int i;

    // Open the device using the VID, PID,
    // and optionally the Serial number.
//     handle = hid_open(0x1532, 0x0c00, NULL);
    handle = hid_open(0x1532, 0x0043, NULL);
    if (!handle) {
        printf("unable to open device\n");
        return 1;
    }

    // Read the Manufacturer String
    wstr[0] = 0x0000;
    res = hid_get_manufacturer_string(handle, wstr, MAX_STR);
    if (res < 0)
        printf("Unable to read manufacturer string\n");
    printf("Manufacturer String: %ls\n", wstr);

    // Read the Product String
    wstr[0] = 0x0000;
    res = hid_get_product_string(handle, wstr, MAX_STR);
    if (res < 0)
        printf("Unable to read product string\n");
    printf("Product String: %ls\n", wstr);

    // Read the Serial Number String
    wstr[0] = 0x0000;
    res = hid_get_serial_number_string(handle, wstr, MAX_STR);
    if (res < 0)
        printf("Unable to read serial number string\n");
    printf("Serial Number String: %ls", wstr);
    printf("\n");

    // Send a Feature Report to the device
    razer_report report;
    memset(&report, 0, sizeof(razer_report));

//     report.status = 0x00;
//     report.transaction_id.id = 0xFF;
//     report.remaining_packets = 0x00;
//     report.protocol_type = 0x00;
//     report.command_class = 0x00;
//     report.command_id.id = 0x82;
//     report.data_size = 0x16;

    const char *buf2 = "100";
    unsigned char brightness = (unsigned char)strtoul(buf2, NULL, 10);

    report = razer_chroma_standard_set_led_brightness(0x01, 0x04, brightness);

    report.razer_report_inner.crc = razer_calculate_crc(&report);
    //int razer_get_usb_response(struct usb_device *usb_dev, uint report_index, struct razer_report* request_report, uint response_index, struct razer_report* response_report, ulong wait_min, ulong wait_max)
    res = hid_send_feature_report(handle, report.Data, 90);
    if (res < 0) {
        printf("Unable to send a feature report.\n");
        printf("%ls\n", hid_error(handle));
    }

    // Read a Feature Report from the device
    res = hid_get_feature_report(handle, buf, sizeof(buf));
    if (res < 0) {
        printf("Unable to get a feature report.\n");
        printf("%ls\n", hid_error(handle));
    } else {
        // Print out the returned buffer.
        printf("Feature Report\n   ");
        for (i = 0; i < res; i++)
            printf("%02hhx ", buf[i]);
        printf("\n");
    }
}
