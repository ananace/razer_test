#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <hidapi.h>

union transaction_id_union {
    unsigned char id;
    struct transaction_parts {
        unsigned char device : 3;
        unsigned char id : 5;
    } parts;
};

union command_id_union {
    unsigned char id;
    struct command_id_parts {
        unsigned char direction : 1;
        unsigned char id : 7;
    } parts;
};

typedef union razer_report {
    unsigned char Data[91];
    struct {
        unsigned char report_id; /* required by hidraw or something - 0x00 */
        unsigned char status;
        union transaction_id_union transaction_id; /* */
        unsigned char remaining_packets; /* Big Endian */
        unsigned char remaining_packets2; /* should be unsigned short - but breaks stuff */
        unsigned char protocol_type; /*0x0*/
        unsigned char data_size;
        unsigned char command_class;
        union command_id_union command_id;
        unsigned char arguments[80];
        unsigned char crc;/*xor'ed bytes of report*/
        unsigned char reserved; /*0x0*/
    } razer_report_inner;
} razer_report;

/**
 * Calculate the checksum for the usb message
 *
 * Checksum byte is stored in the 2nd last byte in the messages payload.
 * The checksum is generated by XORing all the bytes in the report starting
 * at byte number 2 (0 based) and ending at byte 88.
 */
unsigned char razer_calculate_crc(razer_report *report)
{
    /*second to last byte of report is a simple checksum*/
    /*just xor all bytes up with overflow and you are done*/
    unsigned char crc = 0;
    unsigned char *_report = (unsigned char *) report;

    unsigned int i;
    for (i = 3; i < 89; i++) {
        crc ^= _report[i];
    }

    return crc;
}

razer_report get_razer_report(unsigned char command_class, unsigned char command_id, unsigned char data_size)
{
    razer_report new_report;
    memset(&new_report, 0, sizeof(razer_report));

    new_report.razer_report_inner.status = 0x00;
    new_report.razer_report_inner.transaction_id.id = 0xFF;
    new_report.razer_report_inner.remaining_packets = 0x00;
    new_report.razer_report_inner.protocol_type = 0x00;
    new_report.razer_report_inner.command_class = command_class;
    new_report.razer_report_inner.command_id.id = command_id;
    new_report.razer_report_inner.data_size = data_size;

    return new_report;
}

razer_report razer_chroma_standard_set_led_brightness(unsigned char variable_storage, unsigned char led_id, unsigned char brightness)
{
    razer_report report = get_razer_report(0x03, 0x03, 0x03);
    report.razer_report_inner.arguments[0] = variable_storage;
    report.razer_report_inner.arguments[1] = led_id;
    report.razer_report_inner.arguments[2] = brightness;

    return report;
}


int main(int argc, char *argv[])
{
    int res;
    unsigned char buf[91];
#define MAX_STR 255
    wchar_t wstr[MAX_STR];
    hid_device *handle;
    int i;

    /*struct hid_device_info *devs, *cur_dev;*/

    if (hid_init())
        return -1;

    /*devs = hid_enumerate(0x1532, 0x0043);
    cur_dev = devs;
    while (cur_dev) {
        printf("Device Found\n  type: %04hx %04hx\n  path: %s\n  serial_number: %ls", cur_dev->vendor_id, cur_dev->product_id, cur_dev->path, cur_dev->serial_number);
        printf("\n");
        printf("  Manufacturer: %ls\n", cur_dev->manufacturer_string);
        printf("  Product:      %ls\n", cur_dev->product_string);
        printf("  Release:      %hx\n", cur_dev->release_number);
        printf("  Interface:    %d\n",  cur_dev->interface_number);
        printf("\n");
        if (cur_dev->interface_number == 2) { // See https://github.com/cyanogen/uchroma/blob/2b8485e5ac931980bacb125b8dff7b9a39ea527f/uchroma/server/device_manager.py#L141-L155
            break;
        }
        cur_dev = cur_dev->next;
    }
    char *dev_path = strdup(cur_dev->path);
    if (dev_path == NULL) {
        printf("failed to copy path string\n");
        return 1;
    }
    hid_free_enumeration(devs);*/

    // Open the device using the VID, PID,
    // and optionally the Serial number.
//     handle = hid_open(0x1532, 0x0c00, NULL);
    handle = hid_open(0x1532, 0x0043, NULL);
    /*printf("Path: %s\n", dev_path);
    handle = hid_open_path(dev_path);*/
    if (!handle) {
        printf("unable to open device\n");
        return 1;
    }

    // Read the Manufacturer String
    wstr[0] = 0x0000;
    res = hid_get_manufacturer_string(handle, wstr, MAX_STR);
    if (res < 0)
        printf("Unable to read manufacturer string\n");
    printf("Manufacturer String: %ls\n", wstr);

    // Read the Product String
    wstr[0] = 0x0000;
    res = hid_get_product_string(handle, wstr, MAX_STR);
    if (res < 0)
        printf("Unable to read product string\n");
    printf("Product String: %ls\n", wstr);

    // Send a Feature Report to the device
    razer_report report;
    memset(&report, 0, sizeof(razer_report));

    unsigned char brightness = 0xff; // 0x00 -> 0xff
//     brightness = 0x1A; // 26 in hex
    printf("Setting brightness: 0x%02X\n", brightness);

    report = razer_chroma_standard_set_led_brightness(0x01, 0x04, brightness);

    report.razer_report_inner.crc = razer_calculate_crc(&report);

    res = hid_send_feature_report(handle, report.Data, 91);
    if (res < 0) {
        printf("Unable to send a feature report.\n");
    }

    // Read a Feature Report from the device
    res = hid_get_feature_report(handle, buf, sizeof(buf));
    if (res < 0) {
        printf("Unable to get a feature report.\n");
    } else {
        // Print out the returned buffer.
        printf("Feature Report\n   ");
        for (i = 0; i < res; i++)
            printf("%02hhx ", buf[i]);
        printf("\n");
    }
}
